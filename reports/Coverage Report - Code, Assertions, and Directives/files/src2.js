var g_data = {"name":"top/top.sv","src":"import uvm_pkg::*;\nimport APB_env_pkg::*;\nimport APB_test_pkg::*;\nimport shared_pkg::*; // For enums and parameters\n`timescale `TIME_UNIT / `TIME_PRECISION\n\nmodule tb_top;\n    bit clk;\n    // Clock Generation\n    initial begin\n        clk = `LOW;\n        forever #(`CLK_PERIOD/2) clk = ~ clk;\n    end\n\n    \n    APB_env env_instance; // Instantiate the APB4 enviroment\n    APB_test_base test; // Instantiate the APB4 test\n\n    // Instantiate the interface\n    APB_if apb_if (clk);\n    // Instantiating the APB_Wrapper module and connecting it to the APB interface signals\n    APB_Wrapper DUT (\n        .PCLK(apb_if.PCLK),\n        .PRESETn(apb_if.PRESETn),\n        .SWRITE(apb_if.SWRITE),\n        .SADDR(apb_if.SADDR),\n        .SWDATA(apb_if.SWDATA),\n        .SSTRB(apb_if.SSTRB),\n        .SPROT(apb_if.SPROT),\n        .transfer(apb_if.transfer),\n        .PRDATA(apb_if.PRDATA)\n        );\n\n        // Hierarchical Referencing to access internal signals in the DUT\n        assign apb_if.PREADY  = DUT.Slave.PREADY;  \n        assign apb_if.PSLVERR = DUT.Slave.PSLVERR;\n        assign apb_if.PENABLE = DUT.Slave.PENABLE;\n        assign apb_if.PSEL = DUT.Slave.PSEL;\n        assign apb_if.cs = shared_pkg::state_e'(DUT.Master.cs);\n\n        assign apb_if.PWRITE  = DUT.PWRITE;  \n        assign apb_if.PADDR = DUT.PADDR;\n        assign apb_if.PWDATA = DUT.PWDATA;\n        assign apb_if.PSTRB = DUT.PSTRB;\n        assign apb_if.PPROT = DUT.PPROT;\n\n\n    golden_model GLD (\n        .PCLK(apb_if.PCLK),\n        .PRESETn(apb_if.PRESETn),\n        .SWRITE(apb_if.SWRITE),\n        .SADDR(apb_if.SADDR),\n        .SWDATA(apb_if.SWDATA),\n        .SSTRB(apb_if.SSTRB),\n        .SPROT(apb_if.SPROT),\n        .transfer(apb_if.transfer),\n        .PRDATA(apb_if.PRDATA_ref)\n        );\n\n        // Access internal signals in the golden model\n        assign apb_if.PREADY_ref  = GLD.PREADY;  \n        assign apb_if.PSLVERR_ref = GLD.PSLVERR;\n        assign apb_if.PENABLE_ref = GLD.PENABLE;\n        assign apb_if.PSEL_ref = GLD.PSEL;\n        assign apb_if.PWRITE_ref  = GLD.PWRITE;  \n        assign apb_if.PADDR_ref = GLD.PADDR;\n        assign apb_if.PWDATA_ref = GLD.PWDATA;\n        assign apb_if.PSTRB_ref = GLD.PSTRB;\n        assign apb_if.PPROT_ref = GLD.PPROT;\n\n    // Binding the APB_sva module (SystemVerilog Assertions) to the APB_Wrapper instance\n    bind APB_Wrapper APB_sva APB_sva_inst (\n        .PCLK(PCLK),\n        .PRESETn(PRESETn),\n        .SWRITE(SWRITE),\n        .SADDR(SADDR),\n        .SWDATA(SWDATA),\n        .SSTRB(SSTRB),\n        .SPROT(SPROT),\n        .transfer(transfer),\n        .PRDATA(PRDATA),\n        .PREADY(DUT.Slave.PREADY),\n        .PSLVERR(DUT.Slave.PSLVERR),\n        .PENABLE(DUT.Slave.PENABLE),\n        .PSEL(DUT.Slave.PSEL),\n        .PWRITE(DUT.PWRITE),\n        .PADDR(DUT.PADDR),\n        .PWDATA(DUT.PWDATA),\n        .PSTRB(DUT.PSTRB),\n        .PPROT(DUT.PPROT),\n        .cs(DUT.Master.cs),\n        .ns(DUT.Master.ns)\n        );    \n\n    initial begin\n        uvm_top.set_report_verbosity_level(UVM_MEDIUM); // Set verbosity level\n        uvm_top.finish_on_completion = `DISABLE_FINISH; // Prevent UVM from calling $finish\n        uvm_config_db#(virtual APB_if)::set(null, \"*\", \"apb_if\", apb_if); // Set APB interface globally\n        run_test(\"APB_test_base\"); // Start the UVM test\n        $stop; // Stop simulation after test execution\n    end\nendmodule : tb_top","lang":"verilog"};
processSrcData(g_data);